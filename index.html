<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC èŠå¤©å®¤</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lz-string/1.4.4/lz-string.min.js"></script>
    <style>
        body { font-family: 'Segoe UI', 'Microsoft JhengHei', sans-serif; max-width: 600px; margin: 20px auto; padding: 10px; background: #f0f2f5; color: #333; }
        .box { background: white; padding: 25px; border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.08); text-align: center; transition: all 0.3s; }
        
        /* æŒ‰éˆ•æ¨£å¼ */
        button { 
            width: 100%; padding: 12px; margin: 8px 0; cursor: pointer; border: none; border-radius: 8px; 
            color: white; font-size: 16px; font-weight: 600; transition: 0.2s; 
        }
        button:hover { filter: brightness(90%); transform: translateY(-1px); }
        button:active { transform: translateY(0); }
        .btn-host { background: linear-gradient(135deg, #007bff, #0056b3); }
        .btn-guest { background: linear-gradient(135deg, #28a745, #1e7e34); }
        .btn-reset { background: #dc3545; font-size: 13px; padding: 8px; margin-top: 15px; width: auto; opacity: 0.8; }
        .btn-send { background: #6c757d; width: 80px; margin-left: 8px; }

        /* é€²åº¦æ¢æ¨£å¼ */
        .progress-container { margin: 20px 0; text-align: left; display: none; }
        .progress-bg { height: 10px; background: #e9ecef; border-radius: 5px; overflow: hidden; }
        .progress-bar { 
            height: 100%; background: linear-gradient(90deg, #00c6ff, #0072ff); width: 0%; 
            transition: width 0.5s ease; border-radius: 5px; 
        }
        .status-text { font-size: 14px; margin-top: 8px; font-weight: bold; color: #555; display: flex; justify-content: space-between; }
        .time-est { color: #888; font-weight: normal; font-size: 13px; }

        /* èŠå¤©å®¤èˆ‡æ—¥èªŒ */
        .chat-container { display: none; margin-top: 20px; text-align: left; }
        #msg-history { height: 350px; overflow-y: auto; border: 1px solid #dee2e6; background: #fff; padding: 15px; border-radius: 8px; display: flex; flex-direction: column; gap: 8px; }
        .msg { padding: 8px 14px; border-radius: 18px; max-width: 75%; word-wrap: break-word; font-size: 15px; line-height: 1.4; }
        .msg-self { background-color: #0084ff; color: white; align-self: flex-end; border-bottom-right-radius: 4px; }
        .msg-remote { background-color: #e4e6eb; color: black; align-self: flex-start; border-bottom-left-radius: 4px; }
        .input-group { display: flex; margin-top: 15px; }
        #msg-input { flex: 1; padding: 12px; border: 1px solid #ddd; border-radius: 8px; outline: none; }
        #msg-input:focus { border-color: #007bff; }

        #log { font-size: 12px; color: #777; margin-top: 20px; border-top: 1px solid #eee; padding-top: 10px; text-align: center; }
    </style>
</head>
<body>

<div class="box" id="setup">
    <h2>WebRTC èŠå¤©å®¤ (ä¿®å¾©ç‰ˆ)</h2>
    <p style="color: #666; margin-bottom: 20px;">ä½¿ç”¨ ThingSpeak ä½œç‚ºä¿¡ä»¤ä¼ºæœå™¨</p>
    
    <button class="btn-host" onclick="init('host')">æˆ‘æ˜¯æˆ¿ä¸» (å»ºç«‹æˆ¿é–“)</button>
    <button class="btn-guest" onclick="init('guest')">æˆ‘æ˜¯è¨ªå®¢ (åŠ å…¥æˆ¿é–“)</button>
    
    <div class="progress-container" id="progress-box">
        <div class="progress-bg">
            <div class="progress-bar" id="p-bar"></div>
        </div>
        <div class="status-text">
            <span id="p-status">æº–å‚™ä¸­...</span>
            <span id="p-time" class="time-est"></span>
        </div>
    </div>

    <button class="btn-reset" onclick="forceReset()">âš ï¸ é€£ç·šå¡ä½ï¼Ÿé»æˆ‘é‡ç½®</button>
</div>

<div class="box chat-container" id="chat-ui">
    <h3 style="margin:0 0 15px 0; color:#007bff;">ğŸ’¬ ç·šä¸ŠèŠå¤©å®¤</h3>
    <div id="msg-history"></div>
    <div class="input-group">
        <input type="text" id="msg-input" placeholder="è¼¸å…¥è¨Šæ¯..." onkeypress="if(event.key==='Enter') sendMsg()">
        <button class="btn-send" onclick="sendMsg()">å‚³é€</button>
    </div>
</div>

<div id="log">ç³»çµ±å°±ç·’</div>

<script>
    // --- è¨­å®šå€ ---
    const TS_CHANNEL_ID = "3212982";
    const TS_WRITE_KEY  = "X4HBYP2ZX6IN166N";
    const TS_READ_KEY   = "IBRMSZOSXH3W1HHL";
    const rtcConfig = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };
    
    // --- è®Šæ•¸ ---
    let pc, dc, role, pollTimer;
    let localCompressedOffer = null;

    // --- é€²åº¦æ¢æ§åˆ¶ ---
    function updateProgress(percent, text, timeText = "") {
        document.getElementById('progress-box').style.display = 'block';
        document.getElementById('p-bar').style.width = percent + '%';
        if(text) document.getElementById('p-status').innerText = text;
        if(timeText) document.getElementById('p-time').innerText = timeText;
    }

    // --- å¼·åˆ¶é‡ç½® ---
    async function forceReset() {
        if(!confirm("ç¢ºå®šè¦é‡ç½®å—ï¼Ÿé€™å°‡æœƒä¸­æ–·ç›®å‰çš„é€£ç·šå˜—è©¦ã€‚")) return;
        updateProgress(0, "æ­£åœ¨å¼·åˆ¶é‡ç½®...", "è«‹ç¨å€™");
        try {
            // åŠ ä¸Šæ™‚é–“æˆ³é˜²æ­¢å¿«å–
            await fetch(`https://api.thingspeak.com/update?api_key=${TS_WRITE_KEY}&field1=reset&field2=&field3=&field4=&t=${Date.now()}`);
            updateProgress(0, "é‡ç½®å®Œæˆï¼", "è«‹é‡æ–°æ•´ç†ç¶²é ");
            alert("é‡ç½®æˆåŠŸï¼Œè«‹é‡æ–°æ•´ç†ç¶²é å¾Œå†è©¦ã€‚");
            location.reload();
        } catch(e) { alert("é‡ç½®å¤±æ•—ï¼Œè«‹æª¢æŸ¥ç¶²è·¯ã€‚"); }
    }

    // --- æ ¸å¿ƒåˆå§‹åŒ– ---
    async function init(userRole) {
        role = userRole;
        // éš±è—æŒ‰éˆ•ï¼Œé¡¯ç¤ºé€²åº¦æ¢
        document.querySelectorAll('#setup button:not(.btn-reset)').forEach(b => b.style.display = 'none');
        
        pc = new RTCPeerConnection(rtcConfig);

        // 1. é€£ç·šç‹€æ…‹
        pc.onconnectionstatechange = () => {
            console.log("Connection State:", pc.connectionState);
            if(pc.connectionState === 'connected') {
                updateProgress(100, "é€£ç·šæˆåŠŸï¼", "é€²å…¥èŠå¤©å®¤");
                setTimeout(() => {
                    document.getElementById('setup').style.display = 'none';
                    document.getElementById('chat-ui').style.display = 'block';
                    document.getElementById('log').style.display = 'none';
                }, 800);
                stopPoll();
            } else if (pc.connectionState === 'failed') {
                updateProgress(0, "é€£ç·šå¤±æ•—", "è«‹é‡è©¦");
                alert("P2P é€£ç·šå»ºç«‹å¤±æ•—ï¼Œå¯èƒ½æ˜¯ç¶²è·¯é˜²ç«ç‰†é˜»æ“‹");
            }
        };

        // 2. ICE æ”¶é›†
        pc.onicecandidate = e => {
            if (e.candidate === null) {
                // ICE å®Œæˆ
                const cleanSDP = stripSDP(pc.localDescription);
                const compressed = LZString.compressToEncodedURIComponent(JSON.stringify(cleanSDP));
                
                if (role === 'host') {
                    updateProgress(40, "è·¯å¾‘æ”¶é›†å®Œæˆï¼Œä¸Šå‚³ä¸­...", "é è¨ˆç­‰å¾… 2-5 ç§’");
                    uploadToThingSpeak(compressed, 'offer');
                } else {
                    localCompressedOffer = compressed;
                    updateProgress(45, "Answer æº–å‚™å°±ç·’", "ç­‰å¾…é »é“å†·å»æª¢æŸ¥...");
                    // è¨ªå®¢ä¸ç›´æ¥ä¸Šå‚³ï¼Œç­‰å¾… poll é‚è¼¯åˆ¤æ–·å†·å»
                }
            }
        };

        if (role === 'host') {
            dc = pc.createDataChannel("chat");
            setupDC();
            
            updateProgress(10, "æ­£åœ¨æ¸…ç†èˆŠé »é“...", "é è¨ˆ 2 ç§’");
            // åŠ ä¸Šæ™‚é–“æˆ³é˜²æ­¢å¿«å–
            await fetch(`https://api.thingspeak.com/update?api_key=${TS_WRITE_KEY}&field1=reset&t=${Date.now()}`);
            await new Promise(r => setTimeout(r, 1500)); // ç¨ä½œç­‰å¾…ç¢ºä¿å¯«å…¥
            
            updateProgress(20, "å»ºç«‹é€£ç·šè³‡è¨Š...", "æ”¶é›†ç¶²è·¯è·¯å¾‘ä¸­");
            const offer = await pc.createOffer({ offerToReceiveAudio: false, offerToReceiveVideo: false });
            await pc.setLocalDescription(offer);
        } else {
            pc.ondatachannel = e => { dc = e.channel; setupDC(); };
            updateProgress(10, "æ­£åœ¨å°‹æ‰¾æˆ¿ä¸»è¨Šè™Ÿ...", "è«‹ç¨å€™...");
            pollThingSpeak('offer');
        }
    }

    // --- è¼”åŠ©åŠŸèƒ½ ---
    function stripSDP(desc) {
        let sdp = desc.sdp;
        // ç§»é™¤ä¸å¿…è¦çš„è¡Œä»¥æ¸›å°‘å­—å…ƒæ•¸
        const lines = sdp.split('\r\n').filter(line => !line.startsWith('a=rtpmap:') && !line.startsWith('a=fmtp:') && !line.startsWith('a=extmap:'));
        return { type: desc.type, sdp: lines.join('\r\n') };
    }

    async function uploadToThingSpeak(dataString, type) {
        const chunks = [];
        // ThingSpeak æ¯å€‹ field ä¸Šé™ 255 bytesï¼Œå®‰å…¨èµ·è¦‹åˆ‡ 250
        for(let i=0; i<dataString.length; i+=250) chunks.push(dataString.substring(i, i+250));
        
        // åŠ ä¸Šæ™‚é–“æˆ³
        let url = `https://api.thingspeak.com/update?api_key=${TS_WRITE_KEY}&field1=${type}&t=${Date.now()}`;
        chunks.forEach((chunk, idx) => url += `&field${idx+2}=${chunk}`);

        console.log(`Uploading ${type}, length: ${dataString.length}, chunks: ${chunks.length}`);

        try {
            const res = await fetch(url);
            const text = await res.text();
            
            if(text == "0") {
                // å›å‚³ 0 ä»£è¡¨å¯«å…¥å¤ªé »ç¹ (15ç§’é™åˆ¶)
                console.warn("å¯«å…¥é »ç‡éé«˜ï¼Œç­‰å¾…é‡è©¦...");
                updateProgress(50, "å¯«å…¥å¤ªå¿«ï¼Œç­‰å¾…å†·å»...", "ç³»çµ±è‡ªå‹•é‡è©¦ä¸­");
                setTimeout(() => uploadToThingSpeak(dataString, type), 5000);
                return;
            }

            if(role === 'host') {
                updateProgress(60, "Offer ä¸Šå‚³å®Œæˆ", "ç­‰å¾…è¨ªå®¢åŠ å…¥...");
                pollThingSpeak('answer');
            } else {
                updateProgress(90, "Answer ä¸Šå‚³å®Œæˆ", "ç­‰å¾… WebRTC æ¡æ‰‹...");
            }
        } catch(e) { 
            updateProgress(0, "ä¸Šå‚³å¤±æ•—", "è«‹æª¢æŸ¥ç¶²è·¯");
            console.error(e); 
        }
    }

    // --- è¼ªè©¢èˆ‡å†·å»é‚è¼¯ (å«å¼·åˆ¶æ›´æ–°) ---
    function pollThingSpeak(expectType) {
        let waitTime = 0;
        
        pollTimer = setInterval(async () => {
            waitTime += 3;
            if(role === 'host' && !localCompressedOffer) {
                 updateProgress(60, "ç­‰å¾…è¨ªå®¢åŠ å…¥...", `å·²ç­‰å¾… ${waitTime} ç§’`);
            } else if (role === 'guest' && !localCompressedOffer) {
                 updateProgress(10, "å°‹æ‰¾æˆ¿é–“ä¸­...", `å·²ç­‰å¾… ${waitTime} ç§’`);
            }

            try {
                // â˜…â˜…â˜… é—œéµä¿®æ”¹ï¼šåŠ ä¸Š &t=${Date.now()} å¼·åˆ¶ç€è¦½å™¨ä¸ä½¿ç”¨å¿«å– â˜…â˜…â˜…
                const res = await fetch(`https://api.thingspeak.com/channels/${TS_CHANNEL_ID}/feeds/last.json?api_key=${TS_READ_KEY}&t=${Date.now()}`);
                const data = await res.json();
                
                console.log(`[Poll] Expect: ${expectType}, Got: ${data.field1}, ID: ${data.entry_id}`);

                if(data.field1 === expectType && data.field2) {
                    stopPoll();
                    
                    // è§£å£“ç¸®
                    let raw = "";
                    for(let i=2; i<=8; i++) if(data[`field${i}`]) raw += data[`field${i}`];
                    
                    try {
                        const remoteDesc = JSON.parse(LZString.decompressFromEncodedURIComponent(raw));
                        
                        if(role === 'host') {
                            updateProgress(80, "æ”¶åˆ°è¨ªå®¢å›æ‡‰ï¼", "æ­£åœ¨å»ºç«‹ P2P é€£ç·š...");
                            await pc.setRemoteDescription(remoteDesc);
                        } 
                        else if (role === 'guest') {
                            updateProgress(30, "æ‰¾åˆ°æˆ¿é–“ï¼", "æ­£åœ¨åˆ†æé€£ç·šè³‡è¨Š...");
                            await pc.setRemoteDescription(remoteDesc);
                            
                            // è¨ˆç®—å†·å»
                            const offerTime = new Date(data.created_at).getTime();
                            const now = new Date().getTime();
                            const elapsed = now - offerTime;
                            const SAFE_DELAY = 16000; // 16ç§’ç·©è¡
                            
                            const answer = await pc.createAnswer();
                            await pc.setLocalDescription(answer);
                            await waitForIce();

                            if (elapsed < SAFE_DELAY) {
                                const remaining = Math.ceil((SAFE_DELAY - elapsed) / 1000);
                                startCountdown(remaining);
                            } else {
                                updateProgress(70, "ç„¡éœ€ç­‰å¾…", "æ­£åœ¨ä¸Šå‚³ Answer...");
                                uploadToThingSpeak(localCompressedOffer, 'answer');
                            }
                        }
                    } catch (err) {
                        console.error("è§£æå¤±æ•—", err);
                    }
                }
            } catch(e) { console.log("Polling error...", e); }
        }, 3000);
    }

    // --- å€’æ•¸è¨ˆæ™‚å™¨ ---
    function startCountdown(seconds) {
        let counter = seconds;
        const timer = setInterval(() => {
            updateProgress(60, "é »é“å†·å»ä¸­ (é˜²è¡çª)", `é‚„éœ€ç­‰å¾… ${counter} ç§’...`);
            counter--;
            if (counter < 0) {
                clearInterval(timer);
                updateProgress(75, "å†·å»çµæŸ", "æ­£åœ¨ä¸Šå‚³å›æ‡‰...");
                uploadToThingSpeak(localCompressedOffer, 'answer');
            }
        }, 1000);
    }

    function stopPoll() { clearInterval(pollTimer); }
    function waitForIce() { return new Promise(r => { const i = setInterval(() => { if(localCompressedOffer){ clearInterval(i); r(); }}, 100); }); }
    
    // --- èŠå¤© UI ---
    function setupDC() {
        dc.onopen = () => console.log("Channel Open");
        dc.onmessage = e => addMsg("å°æ–¹", e.data, 'remote');
    }
    function sendMsg() {
        const inp = document.getElementById('msg-input');
        if(dc && dc.readyState === 'open' && inp.value.trim()) {
            dc.send(inp.value.trim());
            addMsg("æˆ‘", inp.value.trim(), 'self');
            inp.value = '';
        }
    }
    function addMsg(who, t, type) {
        const h = document.getElementById('msg-history');
        h.innerHTML += `<div class="msg msg-${type}"><b>${who}:</b> ${t}</div>`;
        h.scrollTop = h.scrollHeight;
    }
</script>
</body>
</html>
